////////////////////////////////////////////////////////////////////////////////
//
// Code::Blocks new project wizard script
//
// Project: Sega Dreamcast Project (DreamSDK)
// Author:  The DreamSDK Team
//
////////////////////////////////////////////////////////////////////////////////

// Global Vars
ProjectSettings <- {
    UseRomdisk = false
    ConsoleLang = 0 // Default to C
    SelectedLibraryList = ::wxArrayString()
}
FileSystemObjects <- {
    SoftwareDevelopmentKitHelperDir = _T("")
    MakeRomdiskObjectFile = _T("")
    WizardBaseDir = _T("")
    WizardLibraryInformationDir = _T("")
    TemplateStaticFilesDir = _T("")
    TemplateDynamicFilesDir = _T("")
}
LibraryInformation <- {
    IncludeList = _T("")
    LibraryList = _T("")
}
Referential <- {
    CLanguage = {
        IdStr = _T("")
        IdList = ::wxArrayString()
        IncludeList = ::wxArrayString()
        LibraryList = ::wxArrayString()
    }
    CPPLanguage = {
        IdStr = _T("")
        IdList = ::wxArrayString()
        IncludeList = ::wxArrayString()
        LibraryList = ::wxArrayString()
    }
}

function BeginWizard()
{
    local wiz_type = Wizard.GetWizardType();

    if (wiz_type == wizProject)
    {
        if (!InitializeWizard())
        {
            ShowError(_T("The path of the DreamSDK seems not to be valid.\n" +
                         "Please check if the Global Variable \"dreamsdk_home\" is properly defined."));
            return false;
        }

        // Introduction
        local intro_msg = _T("Welcome to the Sega Dreamcast Project Wizard\n\n" +
                             "This wizard will guide you to create a new Sega Dreamcast project.\n\n" +
                             "When you are ready to proceed, please click \"Next\".");
        Wizard.AddInfoPage(_T("IntroductionPage"), intro_msg);

        // Project Information
        Wizard.AddProjectPathPage();

        // Compiler
        Wizard.AddCompilerPage(_T("GNU GCC Compiler for Sega Dreamcast"), _T("dc-gcc"), true, false);

        // Programming Language
        Wizard.AddGenericSingleChoiceListPage(_T("ConsoleLanguagePage"), _T("Please select the language you want to use."), _T("C;C++"), ProjectSettings.ConsoleLang);

        // Settings
        Wizard.AddPage(_T("SettingsPage"));
    }
    else
        print(wiz_type);
}

function SetupProject(project)
{
    project.SetTargetType(ttNative);

    if (ProjectSettings.UseRomdisk)
    {
        project.SetVar(_T("DREAMSDK_MKRDOBJ"), FileSystemObjects.MakeRomdiskObjectFile, false);
        project.AddCommandsBeforeBuild(_T("$(DREAMSDK_MKRDOBJ) $(PROJECT_DIR)"));
    }

    // Handle libraries
    HandleLibraries(project);

    // Initialize build targets
    local targetDebug = CreateTarget(project, true);
    local targetRelease = CreateTarget(project, false);

    // Debug build target
    InitializeTarget(targetDebug, true);
    SetupDebugger(project);

	// Release build target
	InitializeTarget(targetRelease, false);

	// Add CPP Exception handling support
    if (ProjectSettings.ConsoleLang)
    {
        project.AddCompilerOption(_T("-fexceptions"));
    }

	return true;
}

function GetFilesDir()
{
    local result = _T("");
    if (ProjectSettings.UseRomdisk)
    {
        result = FileSystemObjects.TemplateStaticFilesDir;
    }
    return result;
}

function GetGeneratedFile(file_index)
{
    if (file_index == 0)
    {
        return GenerateSource(_T("main"));
    }
    return _T(""); // no more generated files
}

///////////////////////////////////////////////////////////////////////////////
// GUI Events
///////////////////////////////////////////////////////////////////////////////

function OnEnter_ConsoleLanguagePage(fwd)
{
    Wizard.SetListboxSelection(_T("GenericChoiceList"), ProjectSettings.ConsoleLang);
    return true;
}

function OnLeave_ConsoleLanguagePage(fwd)
{
    if (fwd)
    {
        ProjectSettings.ConsoleLang = Wizard.GetListboxSelection(_T("GenericChoiceList"));
    }
    return true;
}

function OnEnter_SettingsPage(fwd)
{
    if (fwd)
    {
        Wizard.FillContainerWithChoices(_T("lstLibraries"), GetReferentialId());
    }
    return true;
}

function OnLeave_SettingsPage(fwd)
{
    if (fwd)
    {
        ProjectSettings.UseRomdisk = Wizard.IsCheckboxChecked(_T("cbxUseRomdisk"));
        ProjectSettings.SelectedLibraryList = GetArrayFromString(Wizard.GetCheckListboxStringChecked(_T("lstLibraries")), _T(";"), false);
        GenerateUserLibraryInformation();
    }

    return true;
}

///////////////////////////////////////////////////////////////////////////////
// Defined Functions
///////////////////////////////////////////////////////////////////////////////

function LoadReferential(isLangCPP)
{
    local id = GetFileLibraryInfo(isLangCPP, _T("id"));
    local idList = GetArrayFromString(id, _T(";"), false);
    local inc = GetArrayFromString(GetFileLibraryInfo(isLangCPP, _T("inc")), _T(";"), false);
    local lib = GetArrayFromString(GetFileLibraryInfo(isLangCPP, _T("lib")), _T(";"), false);

    if (isLangCPP)
    {
        Referential.CPPLanguage.IdStr = id;
        Referential.CPPLanguage.IdList = idList;
        Referential.CPPLanguage.IncludeList = inc;
        Referential.CPPLanguage.LibraryList = lib;
    }
    else
    {
        Referential.CLanguage.IdStr = id;
        Referential.CLanguage.IdList = idList;
        Referential.CLanguage.IncludeList = inc;
        Referential.CLanguage.LibraryList = lib;
    }
}

function GetReferential()
{
    local result = Referential.CLanguage;
    if (ProjectSettings.ConsoleLang)
    {
        result = Referential.CPPLanguage;
    }
    return result;
}

function GetReferentialId()
{
    return GetReferential().IdStr;
}

function GetReferentialIndex(libraryName)
{
    return GetReferential().IdList.Index(libraryName);
}

function GetReferentialInclude(libraryIndex)
{
    local data = GetReferential().IncludeList.Item(libraryIndex);
    return GetArrayFromString(data, _T("|"), false);
}

function GetReferentialLibrary(libraryIndex)
{
    local data = GetReferential().LibraryList.Item(libraryIndex);
    return GetArrayFromString(data, _T("|"), false);
}

function InitializeWizard()
{
    local result = true;

    // Handle DreamSDK IDE helper directory
    FileSystemObjects.SoftwareDevelopmentKitHelperDir = GetSoftwareDevelopmentKitHelperDir();
    if (!IO.DirectoryExists(FileSystemObjects.SoftwareDevelopmentKitHelperDir))
    {
        return false;
    }

    // Compute Make Romdisk Object File utility
    // This replace basically the genromfs/bin2o commands
    FileSystemObjects.MakeRomdiskObjectFile = FileSystemObjects.SoftwareDevelopmentKitHelperDir + _T("mkrdobj.cmd");

    // Wizard Base Directory
    FileSystemObjects.WizardBaseDir = _T("dc") + wxFILE_SEP_PATH;

    // Wizard Library Information Directory
    FileSystemObjects.WizardLibraryInformationDir = FileSystemObjects.WizardBaseDir + _T("libinfo") + wxFILE_SEP_PATH;

    // Static Files
    FileSystemObjects.TemplateStaticFilesDir = FileSystemObjects.WizardBaseDir + _T("files") + wxFILE_SEP_PATH;

    // Dynamic Files
    FileSystemObjects.TemplateDynamicFilesDir = FileSystemObjects.WizardBaseDir + _T("templates") + wxFILE_SEP_PATH;

    // Libraries Referential (C)
    LoadReferential(false);

    // Libraries Referential (CPP)
    LoadReferential(true);

    if (GetReferential().IdStr.IsEmpty())
    {
        ShowWarning(_T("No KallistiOS libraries are installed.\n" +
                       "You can use DreamSDK Manager to install them."));
    }

    return result;
}

// -----------------------------------------------------------------------------
// add all required libraries to the project
function HandleLibraries(project)
{
    // C++ library
    if (ProjectSettings.ConsoleLang)
    {
        project.AddLinkLib(_T("stdc++"));
    }

    // KallistiOS Ports Libraries
    HandleUserLibraries(project);
}

// -----------------------------------------------------------------------------
// get the DreamSDK home folder for IDE helper scripts
function GetSoftwareDevelopmentKitHelperDir()
{
    local dreamsdk = ReplaceMacros(_T("$(#DREAMSDK_HOME)"), true);

    local result = dreamsdk +
        _T("msys") + wxFILE_SEP_PATH +
        _T("1.0") + wxFILE_SEP_PATH +
        _T("opt") + wxFILE_SEP_PATH +
        _T("dreamsdk") + wxFILE_SEP_PATH +
        _T("ide") + wxFILE_SEP_PATH;

    return result;
}

// -----------------------------------------------------------------------------
// handle user library repository
function GetFileLibraryInfo(isLangCPP, fileId)
{
    local buffer = _T("");
    local langDir = isLangCPP ? _T("cpp") : _T("c");
    local filePath = Wizard.FindTemplateFile(FileSystemObjects.WizardLibraryInformationDir
                                             + langDir + wxFILE_SEP_PATH + fileId + _T(".dat"));
    if (IO.FileExists(filePath))
    {
        buffer = IO.ReadFileContents(filePath);
        buffer.Replace(_T("\r\n"), _T(";"));
        buffer.Replace(_T("\r"), _T(";"));
        buffer.Replace(_T("\n"), _T(";"));

    }
    return buffer;
}

// -----------------------------------------------------------------------------
// generate user library information (includes/libs)
function GenerateUserLibraryInformation()
{
    LibraryInformation.IncludeList = _T("");
    LibraryInformation.LibraryList = _T("");

    for (local i = 0; i < ProjectSettings.SelectedLibraryList.GetCount(); i++)
    {
        local libraryName = ProjectSettings.SelectedLibraryList.Item(i);
        local libraryIndex = GetReferentialIndex(libraryName);

        // Handle includes
        LibraryInformation.IncludeList = LibraryInformation.IncludeList + _T("\r\n// ") + libraryName + _T("\r\n");
        local libraryInc = GetReferentialInclude(libraryIndex);
        for(local j = 0; j < libraryInc.GetCount(); j++)
        {
            LibraryInformation.IncludeList = LibraryInformation.IncludeList + _T("#include <") + libraryInc.Item(j) + _T(">\r\n");
        }

        // Handle libraries
        local sep = (LibraryInformation.LibraryList.IsEmpty()) ? _T("") : _T(";");
        local libraryLink = GetReferentialLibrary(libraryIndex);
        for(local j = 0; j < libraryLink.GetCount(); j++)
        {
            LibraryInformation.LibraryList = LibraryInformation.LibraryList + sep + libraryLink.Item(j);
            sep = _T(";");
        }
    }
}

// -----------------------------------------------------------------------------
// add user library information to the project
function HandleUserLibraries(project)
{
    local libraries = GetArrayFromString(LibraryInformation.LibraryList, _T(";"), false);
    for(local i = 0; i < libraries.GetCount(); i++)
    {
        project.AddLinkLib(libraries.Item(i));
    }
}

// -----------------------------------------------------------------------------
// create the Debug and Release targets
// these targets are mandatory
function CreateTarget(project, isDebugTarget)
{
    local target, targetName;

    if (isDebugTarget)
    {
        targetName = Wizard.GetDebugName();
        target = project.GetBuildTarget(_T("default"));
        if (IsNull(target))
        {
            target = project.AddBuildTarget(targetName);
        }
        else
        {
            project.RenameBuildTarget(_T("default"), targetName);
        }
    }
    else
    {
        targetName = Wizard.GetReleaseName();
        target = project.DuplicateBuildTarget(0, targetName);
    }

    return target;
}

// -----------------------------------------------------------------------------
// initialize the build target
function InitializeTarget(target, isDebugTarget)
{
    local outputDir, outputObjDir;

    if (isDebugTarget)
    {
        outputDir = Wizard.GetDebugOutputDir();
        outputObjDir = Wizard.GetDebugObjectOutputDir();
    }
    else
    {
        outputDir = Wizard.GetReleaseOutputDir();
        outputObjDir = Wizard.GetReleaseObjectOutputDir();
    }

    target.SetTargetType(ttNative);
    target.SetTargetFilenameGenerationPolicy(tgfpPlatformDefault, tgfpNone);
    target.SetOutputFilename(outputDir + Wizard.GetProjectName() + _T(".elf"));
    target.SetObjectOutput(outputObjDir);

    if (ProjectSettings.UseRomdisk)
    {
        target.AddLinkerOption(outputObjDir + _T("romdisk.o"));
    }

    if (isDebugTarget)
    {
        target.AddCompilerOption(_T("-g -Wa,-g -Wl,-g"));
        target.AddCompilerOption(_T("-DDEBUG"));
    }
    else
    {
        target.AddCompilerOption(_T("-O2"));
        target.AddCompilerOption(_T("-DRELEASE"));
    }

    return target;
}

// -----------------------------------------------------------------------------
// configure the debugger parameters
function SetupDebugger(project)
{
    project.AddToExtensions(_T("debugger/remote_debugging/options:conn_type=0"));
    project.AddToExtensions(_T("debugger/remote_debugging/options:ip_address=localhost"));
    project.AddToExtensions(_T("debugger/remote_debugging/options:ip_port=2159"));
    project.AddToExtensions(_T("debugger/remote_debugging/options:loader_waiting_time=0"));
    project.AddToExtensions(_T("debugger/remote_debugging:target=Debug"));
    project.CallHooks(true); // This is NOT a standard method. It uses a patched codeblocks.dll "SDK" library (provided in that trunk)
}

// -----------------------------------------------------------------------------
// Generate the project file unit entry
function GenerateProjectFileUnit(radicalFileName, dotExt)
{
    local fileEntry = radicalFileName + dotExt;
    local path = Wizard.FindTemplateFile(GetTemplateFile(radicalFileName, dotExt));
    local buffer = IO.ReadFileContents(path);
    return fileEntry + _T(";") + SubstituteMacros(buffer);
}

// -----------------------------------------------------------------------------
// return the header contents string
function GenerateHeader(radicalFileName)
{
    return GenerateProjectFileUnit(radicalFileName, DOT_EXT_H);
}

// -----------------------------------------------------------------------------
// return the implementation contents string
function GenerateSource(radicalFileName)
{
    local dotExt = (ProjectSettings.ConsoleLang == 1) ? DOT_EXT_CPP : DOT_EXT_C;
    return GenerateProjectFileUnit(radicalFileName, dotExt);
}

// -----------------------------------------------------------------------------
// return the template's filename, appending <dot_ext> as an extension (must include the dot)
function GetTemplateFile(radicalFileName, dotExt)
{
    return FileSystemObjects.TemplateDynamicFilesDir + radicalFileName + _T("_template") + dotExt;
}

// -----------------------------------------------------------------------------
// substitute all plugin macros in <buffer>
function SubstituteMacros(buffer)
{
    buffer = HandleDirective(buffer, _T("ROMDISK"), ProjectSettings.UseRomdisk);
    buffer = HandleDirective(buffer, _T("KOSLIBS"), ProjectSettings.SelectedLibraryList.GetCount());
    buffer.Replace(_T("[KOSLIBS_INC]"), LibraryInformation.IncludeList);
    buffer.Replace(_T("[PROJECT_NAME]"), Wizard.GetProjectName());
    buffer.Replace(_T("[NOW]"), ReplaceMacros(_T("$(TODAY)"), false));
    return buffer;
}

// -----------------------------------------------------------------------------
// if <enabled> is true, removes the [IF <directive>] and [ENDIF <directive>]
// macros.
// if <enabled> is false, removes everything enclosed by the [IF <directive>]
// and [ENDIF <directive>] macros (including them).
function HandleDirective(buffer, directive, enabled)
{
    local dir_if = _T("[IF ") + directive + _T("]");
    local dir_endif = _T("[ENDIF ") + directive + _T("]");

    while ( true )
    {
        local findStart = buffer.Find(dir_if);
        if (findStart == -1)
            return buffer;

        local findEnd = buffer.Find(dir_endif);
        if (findEnd == -1 || findEnd <= findStart)
            return buffer;

        // look for [ELSE]
        local block = buffer.Mid(findStart, findEnd - findStart);
        local findElse = block.Find(_T("[ELSE]")); // findElse is in "local scope", i.e. offset from findStart

        if (!enabled)
        {
            if (findElse == -1)
            {
                // remove whole section
                buffer.Remove(findStart, (findEnd - findStart) + dir_endif.Length());
            }
            else
            {
                // remove [ENDIF]
                buffer.Remove(findEnd, dir_endif.Length());
                // remove from [IF] to [ELSE] (including)
                buffer.Remove(findStart, findElse + 6); // 6 is the [ELSE] size
            }
        }
        else
        {
            if (findElse == -1)
            {
                // just remove the directives
                // we must remove the [ENDIF] first because if we removed the [IF] it would
                // render the findEnd index invalid!
                buffer.Remove(findEnd, dir_endif.Length());
                buffer.Remove(findStart, dir_if.Length());
            }
            else
            {
                // remove from [ELSE] to [ENDIF]
                local start = findStart + findElse;
                buffer.Remove(start, (findEnd - start) + dir_endif.Length());
                // remove from [IF]
                buffer.Remove(findStart, dir_if.Length());
            }
        }
    }

    return buffer;
}
